#!/bin/sh -u

# Copyright (c) 2017 Masaki Waga
#
# This file is part of vmctl.
#
# Vmctl is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Vmctl is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with vmctl.  If not, see <http://www.gnu.org/licenses/>.


#!@brief abort when user error
# @args message
die_user() {
    echo "$1" > /dev/stderr
    exit 1
}
#!@brief abort when implementation error
# @args message
die_impl() {
    echo "$1" > /dev/stderr
    exit 2
}
#!@brief check if a command is installed
# @args command package-name
# @notice If package-name is omitted, command is used as the package-name
check_cmd() {
    if [ $# -lt 2 ]; then
        package_name=$1
    else
        package_name=$2
    fi
    command -v "$1" > /dev/null 2>&1 || die_user "$package_name is not installed!"
}

conf_file=~/.vmctl.json

if [ "$1" = list ]; then
    jq  -r '.[] | .name,.type' $conf_file | sed 'N;s/\n/ /'
    exit
fi

usage_message="usage: vmctl <command> <server_name>"

## Main Procedure
[ $# -lt 2 ] && die_user "$usage_message"

cmd=$1
while [ $# -ge 2 ]; do
    shift
    server_name=$1
    server_type=$(jq -r --arg name "$server_name" '.[] | if (.name == $name) then .type else empty end' $conf_file)

    if [ "$cmd" = help ]; then
        echo "$usage_message"
        return 0
    fi

    # check if the server exists
    [ -z "$server_type" ] && die_user "Server $server_name is not found!"

    ## dependency check
    check_cmd jq
    case $server_type in
        ec2)
            check_cmd aws aws-cli
            ;;
        virtual_box)
            check_cmd VBoxManage VirtualBox
            ;;
    esac
    printf "%s %s\n" "$server_type" "$server_name"
done | 
    awk '{kind[$1]=kind[$1]" "$2}END{for (key in kind){print key,kind[key]}}' |
    while read -r line; do
        readonly server_type=${line%% *}
        readonly server_names=${line#* }
        case $server_type in
            ec2)
                for server_name in $server_names; do
                    jq -r --arg name "$server_name" '.[] | if (.name == $name) then .instance_id, if (.profile == null) then "default" else .profile end else empty end' $conf_file
                done |
                    xargs -n 2 |
                    case $cmd in
                        start)
                            awk -v cmd_name=start-instances '{kind[$2]=kind[$2]" "$1}END{for (key in kind){printf "aws ec2 %s --profile %s --instance-ids %s\n", cmd_name, key, kind[key]}}' | 
                                xargs -I{} sh -c {}
                            ;;
                        stop)
                            awk -v cmd_name=stop-instances '{kind[$2]=kind[$2]" "$1}END{for (key in kind){printf "aws ec2 %s --profile %s --instance-ids %s\n", cmd_name, key, kind[key]}}' | 
                                xargs -I{} sh -c {}
                            ;;
                        restart)
                            awk -v cmd_name=reboot-instances '{kind[$2]=kind[$2]" "$1}END{for (key in kind){printf "aws ec2 %s --profile %s --instance-ids %s\n", cmd_name, key, kind[key]}}' | 
                                xargs -I{} sh -c {}
                            ;;
                        ip)
                            awk '{kind[$2]=kind[$2]" "$1}END{for (key in kind){printf "aws ec2 describe-instances --query \"Reservations[*].Instances[*].PublicIpAddress[]\" --profile %s --instance-ids %s\n", key, kind[key]}}' | 
                                xargs -I{} sh -c {} |
                                jq -r '.[]'
                            ;;
                        save)
                            die_user 'EC2 insatance cannot be saved!'
                            ;;
                        status)
                            awk '{kind[$2]=kind[$2]" "$1}END{for (key in kind){printf "aws ec2 describe-instances --query \"Reservations[*].Instances[*].State.Name[]\" --profile %s --instance-ids %s\n", key, kind[key]}}' | 
                                xargs -I{} sh -c {} |
                                jq -r '.[]'
                            ;;
                        *)
                            die_user "Unsupported command: $cmd for ec2"
                    esac
                ;;
            virtual_box)
                for server_name in $server_names; do
                    jq -r --arg name "$server_name" '.[] | if (.name == $name) then .instance_id else empty end' $conf_file            
                done |
                    case $cmd in
                        start)
                            xargs -I{} VBoxManage startvm {} --type headless
                            ;;
                        stop)
                            xargs -I{} VBoxManage controlvm {} poweroff
                            ;;
                        restart)
                            xargs -I{} VBoxManage controlvm {} reset
                            ;;
                        save)
                            xargs -I{} VBoxManage controlvm {} savestate
                            ;;
                        status)
                            xargs -I{} VBoxManage showvminfo {} | awk '/State:/ && sub("State: *","")'
                            ;;
                        *)
                            die_user "Unsupported command: $cmd for virtual_box"
                    esac
                ;;
            *)
                die_user "Unsupported server type: $server_type"
        esac
    done
